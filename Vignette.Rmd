---
title: "Introduction to the humcap package"
author: "Salfo Bikienga"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to the humcap package}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

The humcap package provides functions for computing estimates of human capital premiums. The package derives from the "Human Capital Measurement: A Quantiles Regression Approach" paper.

## Installing the package
You will need the devtools package to install packages from github. To install the devtool package, run:
```{r}
#install.packages("devtools")
```

Then install the humcap package as follows:
```{r}
#devtools::install_github("Salfo/humcap")
library(humcap) # load the package
```

The package has essentially two main functions. The hum_cap() function and the mult_hum_cap() function. The hum_cap() function takes a dataset and compute a single human capital premium estimate. The package comes with a dataset.
```{r}
data(cps1990_2013) 
str(cps1990_2013)
```

```{r, message=FALSE, warning=FALSE}
library(dplyr) # dplyr is needed for data subsetting
testdata <- filter(cps1990_2013, state == "Nebraska", year == 2013)
```
```{r}
lin<-lhrswage~educ2+ exp + exp_sq+marst1 # define the model
testmod <- hum_cap(data= testdata, formula = lin, tau = 0.2, weights = testdata$wtsupp, FUN = lm) 
testmod$hc.prem # output human capital premium
```
Uncomment the following code to see the full output of the function.
```{r}
# testmod
```
To use quantile regression estimations, replace the FUN argument lm with rq. But, for the rq function to work, we need to load the quantreg package.

```{r, message=FALSE, warning=FALSE}
require(quantreg) # load the quantreg package
testmod1 <- hum_cap(data= testdata, formula = lin, tau = 0.2, weights = testdata$wtsupp, FUN = rq) 
testmod1$hc.prem # output human capital premium
```
To run the hum_cap() function for multiple years, and multiple states, the mult_hum_cap() function is handy.
```{r, message=FALSE, warning=FALSE}
#testmod11 <- mult_hum_cap(data= cps1990_2013, formula = lin, tau = 0.2,
#weights = testdata$wtsupp, FUN = rq, begin = 2011, end = 2013)
#testmod11 # print output
```
Note that the above code takes time to excecute. That should be expected, since the estimations are done for several states.

## Additional functions
The package provides additional functions for post processing the estimates. 

### RealValueConverter() function
The RealValueConverter() function converts the estimates into real values. The default of the function is the 2013 dollar value. For simplicity, the package provides the estimates of the preinstalled data. These estimates are named testmod2.
```{r}
data(testmod2) # load precomputed estimates
str(testmod2)
head(testmod2[[1]][,1:5], n = 10) # print out few estimates (Nominal values)
head(RealValueConverter(df = testmod2[[1]], begin = 1990, 
                        end = 2013)[,1:6]) # print out few estimates (Real values)
# Another example using RealValueConverter()
head(RealValueConverter(df = testmod2[[1]][,1:6], begin = 1990, end = 1995))
```

### smoother3() function
The smoother3() function produces a three year moving average estimates.
```{r}
smooth_data <- smoother3(testmod2$All)
head(smooth_data[,1:5])
```

### ts_convert() function
The ts_convert() function smooths the estimates, then convert them into a time series format.
```{r}
t_series <- ts_convert(testmod2$All)
head(t_series[, 1:5])
# Another example for limitted years
ts_convert(testmod2$All[,1:5], begin = 1990, end = 1994)[,1:5] # print few states
```

The remainings are details, and should be easy to understand, and possibly extand.

## Construct a barplot of the means

The ggplot2 package is used for most of the graphs in the original paper. This implies that the ggplot2 package must be unstalled and loaded before constructing the following graph.
```{r}
#intall.packages("ggplot2")
library(ggplot2)
barplotData<- RealValueConverter(testmod2$All)

Per_Mean <-as.data.frame(apply(X=barplotData, MARGIN=1, FUN=mean))
states<-c( "AL","AK","AZ","AR","CA","CO","CT","DE",
           "DC","FL","GA","HI","ID","IL","IN","IA",
           "KS","KY","LA","ME","MD","MA","MI","MN",
           "MS","MO","MT","NE","NV","NH","NJ","NM",
           "NY","NC","ND","OH","OK","OR","PA","RI",
           "SC","SD","TN","TX","UT","VT","VA","WA",
           "WV","WI","WY") # Short state names

Period_Mean <- data.frame(states, Per_Mean) # create a dataframe with two variables
names(Period_Mean) <- c("State", "Mean") # Create nicer variables names

Mean_Plot <- ggplot(Period_Mean, aes(reorder(State, Mean), Mean, fill=State)) +
  geom_bar(stat="identity") + coord_flip() + labs(y = "Study Period Average", 
                                                  x = " State") +
  ggtitle("Real Per Capita Hourly Average of HC Wage Premium") + 
  theme(legend.position="none") +  geom_text(aes(State,Mean, label = State, size=0.8)) +
  theme(axis.text.y=element_text(size=rel(0.8)))
```

Print the figure
```{r, fig.height= 6 , fig.width= 8}
print(Mean_Plot)
```

The same function could be used to plot a barplot of the growth rate found in the paper. In the paper, the geometric growth rate is used. To compute the geometric growth rate, the average of the first three estimates are used as the initial value, and the average of the last three estimates are used as the end value.

## Construct a Map
An extended tutorial on how to construct maps can be found at: http://flowingdata.com/2013/07/08/small-maps-and-grids/.
 In the paper, the maps constructed are based on three year moving average data. 
 


